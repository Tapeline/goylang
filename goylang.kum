использовать Файлы

алг
нач
лит исхКод
исхКод := считатьВесьФайл("test.goy")
лит токены
токены := токенизировать(исхКод)
лит асд
асд := спарсить(токены)
цел индекс
лит результат, память
память := новыйОбъект
результат := выполнить(асд, память)
кон



алг лит считатьВесьФайл(арг лит путь) нач 
лит текст = ""
лит строка = ""
файл ф
ф := открыть на чтение("test.goy")
нц пока есть данные(ф)
ввод ф, строка
текст := текст + строка + нс
кц
закрыть(ф)
знач := текст
кон




алг сим __ток_сим(арг лит исхКод, арг цел индекс) нач 
если индекс > длин(исхКод) или индекс < 1 то
знач := юнисимвол(0)
иначе
знач := исхКод[индекс]
все
кон

алг лог __ток_сим_числовой(арг сим с) нач 
знач := (юникод('0') <= юникод(с) <= юникод('9'))
кон

алг лог __ток_сим_буквенный(арг сим с) нач 
знач := (юникод('a') <= юникод(с) <= юникод('z')) или (юникод('A') <= юникод(с) <= юникод('Z')) или с = '_'
кон

алг лог __ток_сим_числобукв(арг сим с) нач 
знач := __ток_сим_числовой(с) или __ток_сим_буквенный(с)
кон

алг лог __ток_сим_пропускать(арг сим с) нач
| Игнорировать \n \t \r и пробел
цел к
к := юникод(с)
знач := к = 9 или к = 10 или к = 13 или к = 32
кон


алг лит __ток_стд_ключ_слова нач
лит т
т := новыйСписок
добавитьККонцуСписка(т, "if")
добавитьККонцуСписка(т, "else")
добавитьККонцуСписка(т, "while")
добавитьККонцуСписка(т, "out")
добавитьККонцуСписка(т, "input")
добавитьККонцуСписка(т, "numinput")
добавитьККонцуСписка(т, "true")
добавитьККонцуСписка(т, "false")
знач := т
кон

алг лит токенизировать(арг лит исхКод) нач 
лит СТД_КЛЮЧ_СЛОВА
СТД_КЛЮЧ_СЛОВА := __ток_стд_ключ_слова
цел текущий = 1
цел старт = 1
сим текущийСим
лит токены
токены := новыйСписок
нц пока текущий <= длин(исхКод)
старт := текущий
текущийСим := исхКод[текущий]
текущий := текущий + 1
выбор 
при __ток_сим_пропускать(текущийСим):
при текущийСим = '(': добавитьККонцуСписка(токены, "(")
при текущийСим = ')': добавитьККонцуСписка(токены, ")")
при текущийСим = '+': добавитьККонцуСписка(токены, "+")
при текущийСим = '-': добавитьККонцуСписка(токены, "-")
при текущийСим = '*': добавитьККонцуСписка(токены, "*")
при текущийСим = '/': добавитьККонцуСписка(токены, "/")
при текущийСим = '#': добавитьККонцуСписка(токены, "#")
при текущийСим = ':': добавитьККонцуСписка(токены, ":")
при текущийСим = '{': добавитьККонцуСписка(токены, "{")
при текущийСим = '}': добавитьККонцуСписка(токены, "}")
при текущийСим = '&': добавитьККонцуСписка(токены, "&")
при текущийСим = '|': добавитьККонцуСписка(токены, "|")
при текущийСим = '=':
если __ток_сим(исхКод, текущий) = '=' то
добавитьККонцуСписка(токены, "==")
текущий := текущий + 1
иначе
добавитьККонцуСписка(токены, "=")
все
при текущийСим = '!':
если __ток_сим(исхКод, текущий) = '=' то
добавитьККонцуСписка(токены, "!=")
текущий := текущий + 1
иначе
добавитьККонцуСписка(токены, "!")
все
при текущийСим = '<':
если __ток_сим(исхКод, текущий) = '=' то
добавитьККонцуСписка(токены, "<=")
текущий := текущий + 1
иначе
добавитьККонцуСписка(токены, "<")
все
при текущийСим = '>':
если __ток_сим(исхКод, текущий) = '=' то
добавитьККонцуСписка(токены, ">=")
текущий := текущий + 1
иначе
добавитьККонцуСписка(токены, ">")
все
при __ток_сим_числовой(текущийСим):
нц пока __ток_сим_числовой(__ток_сим(исхКод, текущий))
текущий := текущий + 1
кц
если __ток_сим(исхКод, текущий) = '.' и __ток_сим_числовой(__ток_сим(исхКод, текущий+1)) то 
текущий := текущий + 1
нц пока __ток_сим_числовой(__ток_сим(исхКод, текущий))
текущий := текущий + 1
кц
все
добавитьККонцуСписка(токены, "N" + исхКод[старт:текущий-1])
при текущийСим = '"':
нц пока __ток_сим(исхКод, текущий) <> '"'
текущий := текущий + 1
кц
если текущий > длин(исхКод) то
паника("ОШИБКА ТОКЕНИЗАЦИИ: неожиданный конец")
выход
все
текущий := текущий + 1
добавитьККонцуСписка(токены, "S" + исхКод[старт:текущий-1])
иначе
нц пока __ток_сим_числобукв(__ток_сим(исхКод, текущий))
текущий := текущий + 1
кц
если найтиВСписке(СТД_КЛЮЧ_СЛОВА, исхКод[старт:текущий-1]) <> -1 то
добавитьККонцуСписка(токены, "K" + исхКод[старт:текущий-1])
иначе
добавитьККонцуСписка(токены, "V" + исхКод[старт:текущий-1])
все
все
кц
знач := токены
кон



алг лит спарсить(арг лит токены) нач 
цел текущий = 1
лит узлы
узлы := новыйСписок
нц пока текущий <= длинаКоллекции(токены)
добавитьККонцуСписка(узлы, сериализовать(__парситьУтверждение(токены, текущий)))
кц
знач := узлы
кон

алг лит __соотв(арг лит токены, аргрез цел текущий, арг лит типТокена) нач
если текущий > длинаКоллекции(токены) то
знач := ""
выход
все
лит токен
токен := получитьИзСписка(токены, текущий)
если __ток_сим_буквенный(типТокена[1]) и токен[1] = типТокена то
текущий := текущий + 1
знач := токен
выход
все
если токен = типТокена то
текущий := текущий + 1
знач := токен
выход
все
знач := ""
кон

алг лит __соотвТекст(арг лит токены, аргрез цел текущий, арг лит текст) нач
если текущий > длинаКоллекции(токены) то
знач := ""
выход
все
лит токен
токен := получитьИзСписка(токены, текущий)
если токен = текст то
текущий := текущий + 1
знач := токен
выход
все
знач := ""
кон

алг лит __новыйУзел(арг лит тип) нач 
лит узел
узел := новыйОбъект
задатьПоКлючу(узел, "тип", тип)
знач := узел
кон

алг лит __новыйУнарныйУзел(арг лит тип, арг лит арг1) нач 
лит узел
узел := новыйОбъект
задатьПоКлючу(узел, "тип", тип)
задатьПоКлючу(узел, "арг", сериализовать(арг1))
знач := узел
кон

алг лит __новыйБинарныйУзел(арг лит тип, арг лит лев, арг лит прав) нач 
лит узел
узел := новыйОбъект
задатьПоКлючу(узел, "тип", тип)
задатьПоКлючу(узел, "лев", сериализовать(лев))
задатьПоКлючу(узел, "прав", сериализовать(прав))
знач := узел
кон

алг лит __требовать(арг лит токены, аргрез цел текущий, арг лит типТокена) нач 
лит токен
токен := __соотв(токены, текущий, типТокена)
если токен = "" то
паника("ОШИБКА ПАРСИНГА: ожидалось " + типТокена)
все
знач := токен
кон

алг лит __новыйIf(арг лит условие, арг лит тело, арг лит телоИначе) нач 
лит узел
узел := новыйОбъект
задатьПоКлючу(узел, "тип", "if")
задатьПоКлючу(узел, "усл", сериализовать(условие))
задатьПоКлючу(узел, "тело", сериализовать(тело))
если телоИначе <> "" то
задатьПоКлючу(узел, "телоИначе", сериализовать(телоИначе))
все
знач := узел
кон

алг лит __новыйWhile(арг лит условие, арг лит тело) нач 
лит узел
узел := новыйОбъект
задатьПоКлючу(узел, "тип", "while")
задатьПоКлючу(узел, "усл", сериализовать(условие))
задатьПоКлючу(узел, "тело", сериализовать(тело))
знач := узел
кон

алг лит __парситьУтверждение(арг лит токены, аргрез цел текущий) нач 
лит тело, утверждение
если __соотв(токены, текущий, "{") <> "" то
тело := новыйСписок
нц пока __соотв(токены, текущий, "}") = ""
утверждение := __парситьУтверждение(токены, текущий)
добавитьККонцуСписка(тело, сериализовать(утверждение))
кц
знач := тело
выход
все
лит условие, телоИначе = ""
если __соотвТекст(токены, текущий, "Kif") <> "" то
условие := __парситьИли(токены, текущий)
тело := __парситьУтверждение(токены, текущий)
если __соотвТекст(токены, текущий, "Kelse") <> "" то
телоИначе := __парситьУтверждение(токены, текущий)
все
знач := __новыйIf(условие, тело, телоИначе)
выход
все
если __соотвТекст(токены, текущий, "Kwhile") <> "" то
условие := __парситьИли(токены, текущий)
тело := __парситьУтверждение(токены, текущий)
знач := __новыйWhile(условие, тело)
выход
все
лит переменная
если __соотвТекст(токены, текущий, "Kinput") <> "" то
переменная := __требовать(токены, текущий, "V")
знач := __новыйУнарныйУзел("input", переменная[2:длин(переменная)])
выход
все
если __соотвТекст(токены, текущий, "Knuminput") <> "" то
переменная := __требовать(токены, текущий, "V")
знач := __новыйУнарныйУзел("numinput", переменная[2:длин(переменная)])
выход
все
если __соотвТекст(токены, текущий, "Kout") <> "" то
переменная := __парситьИли(токены, текущий)
знач := __новыйУнарныйУзел("out", переменная)
выход
все
знач := __парситьПрисваивание(токены, текущий)
кон

алг лит __парситьПрисваивание(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел
лев := __парситьПервичное(токены, текущий)
знач := лев
если __соотв(токены, текущий, "=") <> "" то
прав := __парситьИли(токены, текущий)
узел := __новыйБинарныйУзел("=", лев, прав)
знач := узел
все
кон

алг лит __парситьИли(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел
лев := __парситьИ(токены, текущий)
знач := лев
если __соотв(токены, текущий, "|") <> "" то
прав := __парситьИ(токены, текущий)
узел := __новыйБинарныйУзел("|", лев, прав)
знач := узел
все
кон

алг лит __парситьИ(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел
лев := __парситьРавенство(токены, текущий)
знач := лев
если __соотв(токены, текущий, "&") <> "" то
прав := __парситьРавенство(токены, текущий)
узел := __новыйБинарныйУзел("&", лев, прав)
знач := узел
все
кон

алг лит __парситьРавенство(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел, токен
лев := __парситьНеравенство(токены, текущий)
знач := лев
если __соотв(токены, текущий, "!=") <> "" или __соотв(токены, текущий, "==") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
прав := __парситьНеравенство(токены, текущий)
узел := __новыйБинарныйУзел(токен, лев, прав)
знач := узел
все
кон

алг лит __парситьНеравенство(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел, токен
лев := __парситьСлагаемые(токены, текущий)
знач := лев
если __соотв(токены, текущий, "<") <> "" или __соотв(токены, текущий, ">") <> "" или __соотв(токены, текущий, "<=") <> "" или __соотв(токены, текущий, ">=") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
прав := __парситьСлагаемые(токены, текущий)
узел := __новыйБинарныйУзел(токен, лев, прав)
знач := узел
все
кон

алг лит __парситьСлагаемые(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел, токен
лев := __парситьМножители(токены, текущий)
знач := лев
если __соотв(токены, текущий, "+") <> "" или __соотв(токены, текущий, "-") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
прав := __парситьМножители(токены, текущий)
узел := __новыйБинарныйУзел(токен, лев, прав)
знач := узел
все
кон

алг лит __парситьМножители(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел, токен
лев := __парситьВторичное(токены, текущий)
знач := лев
если __соотв(токены, текущий, "*") <> "" или __соотв(токены, текущий, "/") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
прав := __парситьВторичное(токены, текущий)
узел := __новыйБинарныйУзел(токен, лев, прав)
знач := узел
все
кон

алг лит __парситьВторичное(арг лит токены, аргрез цел текущий) нач 
лит лев, прав, узел
лев := __парситьУнарное(токены, текущий)
знач := лев
если __соотв(токены, текущий, ":") <> "" то
прав := __парситьУнарное(токены, текущий)
узел := __новыйБинарныйУзел(":", лев, прав)
знач := узел
все
кон

алг лит __парситьУнарное(арг лит токены, аргрез цел текущий) нач 
если __соотв(токены, текущий, "#") <> "" то
знач := __новыйУнарныйУзел("#", __парситьПервичное(токены, текущий))
выход
все
знач := __парситьПервичное(токены, текущий)
кон

алг лит __парситьПервичное(арг лит токены, аргрез цел текущий) нач 
лит выражение, токен
если __соотв(токены, текущий, "(") <> "" то
выражение := __парситьПрисваивание(токены, текущий)
токен := __требовать(токены, текущий, ")")
знач := выражение
выход
все

если __соотв(токены, текущий, "N") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
знач := __новыйУнарныйУзел("N", токен[2:длин(токен)])
выход
все

если __соотв(токены, текущий, "S") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
знач := __новыйУнарныйУзел("S", токен[2:длин(токен)-1])
выход
все

если __соотв(токены, текущий, "K") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
выбор
при токен = "true": знач := __новыйУнарныйУзел("B", "true")
при токен = "false": знач := __новыйУнарныйУзел("B", "false")
иначе
паника("ОШИБКА ПАРСИНГА: неожиданный токен " + токен)
все
выход
все

если __соотв(токены, текущий, "V") <> "" то
токен := получитьИзСписка(токены, текущий - 1)
знач := __новыйУнарныйУзел("V", токен[2:длин(токен)])
выход
все

паника("ОШИБКА ПАРСИНГА: неожиданный токен " + получитьИзСписка(токены, текущий))
кон



алг лог __рт_являетсяЧислом(арг лит объект) нач 
знач := получитьПоКлючу(объект, "тип") = "число"
кон

алг лог __рт_являетсяСтрокой(арг лит объект) нач 
знач := получитьПоКлючу(объект, "тип") = "строка"
кон

алг лог __рт_являетсяЛог(арг лит объект) нач 
знач := получитьПоКлючу(объект, "тип") = "лог"
кон

алг лит __рт_новыйОбъект(арг лит тип, арг лит значение) нач 
лит объект
объект := новыйОбъект
задатьПоКлючу(объект, "тип", тип)
задатьПоКлючу(объект, "знач", значение)
знач := объект
кон

алг лит __рт_новыйЛогОбъект(арг лог значение) нач 
лит объект
объект := новыйОбъект
задатьПоКлючу(объект, "тип", "лог")
лит значение_лит
если значение то
значение_лит := "true"
иначе
значение_лит := "false"
все
задатьПоКлючу(объект, "знач", значение_лит)
знач := объект
кон

алг цел __рт_сравнить(арг лит а, арг лит б) нач
если получитьПоКлючу(а, "тип") <> получитьПоКлючу(б, "тип") то
паника("ОШИБКА РАНТАЙМА: нельзя сравнивать данные разных типов")
все
лит тип
тип := получитьПоКлючу(а, "тип")
лог ошибка
вещ ча, чб
лог ла, лб
выбор
при тип = "число":
ча := лит_в_вещ(получитьПоКлючу(а, "знач"), ошибка)
чб := лит_в_вещ(получитьПоКлючу(б, "знач"), ошибка)
если ча = чб то
знач := 0
иначе если ча < чб то 
знач := -1
иначе
знач := 1
все
все
выход
при тип = "строка":
если получитьПоКлючу(а, "знач") = получитьПоКлючу(б, "знач") то
знач := 0
иначе
знач := -1
все
выход
при тип = "лог":
ла := получитьПоКлючу(а, "знач") = "true"
лб := получитьПоКлючу(б, "знач") = "true"
если ла = лб то
знач := 0
иначе
знач := -1
все
выход
все
знач := -1
кон


алг лит выполнить(арг лит узел, аргрез лит память) нач 
цел индекс
лит результат
если являетсяСписком(узел) то
нц для индекс от 1 до длинаКоллекции(узел)
результат := выполнить(десериализовать(получитьИзСписка(узел, индекс)), память)
кц
знач := результат
выход
все

лит типУзла
типУзла := получитьПоКлючу(узел, "тип")

лит а, б
вещ ча, чб
лог ошибка
если типУзла = "+" или типУзла = "-" или типУзла = "*" или типУзла = "/" то
а := выполнить(десериализовать(получитьПоКлючу(узел, "лев")), память)
б := выполнить(десериализовать(получитьПоКлючу(узел, "прав")), память)
если __рт_являетсяСтрокой(а) и __рт_являетсяСтрокой(б) и типУзла = "+" то 
знач := __рт_новыйОбъект("строка", получитьПоКлючу(а, "знач") + получитьПоКлючу(б, "знач"))
выход
все
если не __рт_являетсяЧислом(а) или не __рт_являетсяЧислом(б) то
паника("ОШИБКА РАНТАЙМА: недопустимая операция " + типУзла + " над " + а + " и " + б)
все
ча := лит_в_вещ(получитьПоКлючу(а, "знач"), ошибка)
чб := лит_в_вещ(получитьПоКлючу(б, "знач"), ошибка)
выбор
при типУзла = "+": знач := __рт_новыйОбъект("число", вещ_в_лит(ча + чб))
при типУзла = "-": знач := __рт_новыйОбъект("число", вещ_в_лит(ча - чб))
при типУзла = "*": знач := __рт_новыйОбъект("число", вещ_в_лит(ча * чб))
при типУзла = "/": знач := __рт_новыйОбъект("число", вещ_в_лит(ча / чб))
все
выход
все

цел сравн
если типУзла = "<" или типУзла = ">" или типУзла = "<=" или типУзла = ">=" или типУзла = "!=" или типУзла = "==" то
а := выполнить(десериализовать(получитьПоКлючу(узел, "лев")), память)
б := выполнить(десериализовать(получитьПоКлючу(узел, "прав")), память)
сравн := __рт_сравнить(а, б)
вывод сравн, нс
выбор
при типУзла = "<" и сравн = -1: знач := __рт_новыйЛогОбъект(да)
при типУзла = ">" и сравн = 1: знач := __рт_новыйЛогОбъект(да)
при типУзла = "<=" и (сравн = -1 или сравн = 0): знач := __рт_новыйЛогОбъект(да)
при типУзла = ">=" и (сравн = 1 или сравн = 0): знач := __рт_новыйЛогОбъект(да)
при типУзла = "==" и сравн = 0: знач := __рт_новыйЛогОбъект(да)
при типУзла = "!=" и сравн <> 0: знач := __рт_новыйЛогОбъект(да)
иначе знач := __рт_новыйЛогОбъект(нет)
все
выход
все

если типУзла = "=" то
а := десериализовать(получитьПоКлючу(десериализовать(получитьПоКлючу(узел, "лев")), "арг"))
б := выполнить(десериализовать(получитьПоКлючу(узел, "прав")), память)
задатьПоКлючу(память, а, сериализовать(б))
знач := б 
выход
все

если типУзла = "!" то
а := выполнить(десериализовать(получитьПоКлючу(узел, "арг")), память)
если не __рт_являетсяЛог(а) то паника("ОШИБКА РАНТАЙМА: нельзя ! над не-лог") все
знач := __рт_новыйЛогОбъект(не(получитьПоКлючу(а, "знач") = "true"))
выход
все

если типУзла = "#" то
а := выполнить(десериализовать(получитьПоКлючу(узел, "арг")), память)
если не __рт_являетсяСтрокой(а) то паника("ОШИБКА РАНТАЙМА: нельзя # над не-строкой") все
знач := __рт_новыйОбъект("число", цел_в_лит(длин(получитьПоКлючу(а, "знач"))))
выход
все

если типУзла = "B" то
а := десериализовать(получитьПоКлючу(узел, "арг"))
знач := __рт_новыйЛогОбъект(а = "true")
выход
все

если типУзла = "S" то
а := десериализовать(получитьПоКлючу(узел, "арг"))
знач := __рт_новыйОбъект("строка", а)
выход
все

если типУзла = "N" то
а := десериализовать(получитьПоКлючу(узел, "арг"))
знач := __рт_новыйОбъект("число", а)
выход
все

лит данныеВвода
если типУзла = "input" то
а := десериализовать(получитьПоКлючу(узел, "арг"))
ввод данныеВвода
б := __рт_новыйОбъект("строка", данныеВвода)
задатьПоКлючу(память, а, сериализовать(б))
знач := б
выход
все

вещ данныеЧислВвода
если типУзла = "numinput" то
а := десериализовать(получитьПоКлючу(узел, "арг"))
ввод данныеЧислВвода
б := __рт_новыйОбъект("число", вещ_в_лит(данныеЧислВвода))
задатьПоКлючу(память, а, сериализовать(б))
знач := б
выход
все

если типУзла = "out" то
а := выполнить(десериализовать(получитьПоКлючу(узел, "арг")), память)
вывод получитьПоКлючу(а, "знач"), нс
знач := получитьПоКлючу(а, "знач")
выход
все

если типУзла = "V" то
а := десериализовать(получитьПоКлючу(узел, "арг"))
если не имеетКлюч(память, а) то паника("ОШИБКА РАНТАЙМА: переменная " + а + " не существует") все
знач := десериализовать(получитьПоКлючу(память, а))
выход
все

лог условие
если типУзла = "if" то
а := выполнить(десериализовать(получитьПоКлючу(узел, "усл")), память)
условие := __рт_являетсяЛог(а) и получитьПоКлючу(а, "знач") = "true" 
если условие то 
знач := выполнить(десериализовать(получитьПоКлючу(узел, "тело")), память)
иначе если имеетКлюч(узел, "телоИначе") то
знач := выполнить(десериализовать(получитьПоКлючу(узел, "телоИначе")), память)
все
все
знач := __рт_новыйЛогОбъект(нет)
выход
все

если типУзла = "while" то
знач := __рт_новыйЛогОбъект(нет)
нц
а := выполнить(десериализовать(получитьПоКлючу(узел, "усл")), память)
условие := __рт_являетсяЛог(а) и получитьПоКлючу(а, "знач") = "true" 
если не условие то выход все
знач := выполнить(десериализовать(получитьПоКлючу(узел, "тело")), память)
кц
выход
все
кон













| 
| Kumir Panic API
| @author Tapeline
| @version 1
| 

алг паника(арг лит причина) нач
вывод "=== ПАНИКА ===", нс , причина, нс, "--- паника ---", нс
утв нет
кон




|
| Kumir Collections API
| @author Tapeline
| @version 1
|        
| разделитель u29, префикс u28, объект разделитель u30
| 

алг сим __кк__разделитель нач знач := юнисимвол(29) кон
алг сим __кк__префикс нач знач := юнисимвол(28) кон
алг сим __кк__объект_разделитель нач знач := юнисимвол(30) кон
алг цел __индексПовторенияНомер(арг лит строка, арг сим поиск, арг цел повтор) нач
цел указатель = 1
цел повторение = 0
лог найден = нет
нц для указатель от 1 до длин(строка) 
если строка[указатель] = поиск то
повторение := повторение + 1
все
если повторение = повтор то
знач := указатель
найден := да
выход
все
кц
если не найден то
знач := -1
все
кон



| List implementation

алг лит новыйСписок нач
знач := "" + __кк__префикс + "L0";
кон


алг лог являетсяКоллекцией(арг лит объект) нач
если длин(объект) < 2 то
знач := нет
выход
все
знач := объект[1] = __кк__префикс
кон


алг лог являетсяСписком(арг лит объект) нач
знач := являетсяКоллекцией(объект) и объект[2] = 'L'
кон


алг цел длинаКоллекции(арг лит коллекция) 
дано являетсяКоллекцией(коллекция)
нач
лит длинСтр = ""
цел указатель = 3
нц пока указатель <= длин(коллекция) и юникод('0') <= юникод(коллекция[указатель]) <= юникод('9')
длинСтр := длинСтр + коллекция[указатель]
указатель := указатель + 1
кц
лог успех
знач := лит_в_цел(длинСтр, успех)
если не успех то
знач := 0
все
кон


алг добавитьКСписку(аргрез лит список, арг лит значение, арг цел позиция)
дано являетсяСписком(список)
нач
цел длина0 
длина0 := длинаКоллекции(список)
лит список1
список1 := __кк__префикс + 'L' + цел_в_лит(длина0 + 1)
список1 := список1 + список[__индексПовторенияНомер(список, __кк__разделитель, 1):__индексПовторенияНомер(список, __кк__разделитель, позиция)]
список1 := список1 + значение
список1 := список1 + список[__индексПовторенияНомер(список, __кк__разделитель, позиция):длин(список)]
список := список1
кон


алг добавитьККонцуСписка(аргрез лит список, арг лит значение) нач
цел длина0 
длина0 := длинаКоллекции(список)
лит список1
список1 := __кк__префикс + 'L' + цел_в_лит(длина0 + 1)
цел i 
i := __индексПовторенияНомер(список, __кк__разделитель, 1)
если i < 1 то i := 4 все
если i > длин(список) то 
список1 := список1 + __кк__разделитель + значение
иначе
список1 := список1 + список[i:длин(список)] + __кк__разделитель + значение
все
список := список1
кон


алг лит получитьИзСписка(арг лит список, арг цел позиция)
дано являетсяСписком(список) и длинаКоллекции(список) >= позиция
нач
цел старт, конец
старт := __индексПовторенияНомер(список, __кк__разделитель, позиция) + 1
конец := __индексПовторенияНомер(список, __кк__разделитель, позиция + 1) - 1
если конец < 1 то конец := длин(список) все
знач := список[старт:конец] 
кон


алг удалитьИзСписка(аргрез лит список, арг цел позиция)
дано являетсяСписком(список) и длинаКоллекции(список) >= позиция
нач
цел длина0 
длина0 := длинаКоллекции(список)
лит список1
список1 := __кк__префикс + 'L' + цел_в_лит(длина0 - 1)
цел индекс = 0
цел указатель = 3
лог ужеДобавили = нет
нц
если список[указатель] = __кк__разделитель то выход все
указатель := указатель + 1
кц
нц пока указатель <= длин(список) 
если не (индекс = позиция) то
список1 := список1 + список[указатель]
все
если список[указатель] = __кк__разделитель то
индекс := индекс + 1
все
указатель := указатель + 1
кц
список := список1
кон


алг цел найтиВСписке(арг лит список, арг лит поиск)
дано являетсяСписком(список)
нач
если длинаКоллекции(список) = 0 то 
знач := -1 
выход 
все
цел индекс = -1
лог найден = нет
нц для индекс от 1 до длинаКоллекции(список)
если получитьИзСписка(список, индекс) = поиск то
знач := индекс
найден := да
выход
все
кц
если не найден то
знач := -1
все
кон


алг заменитьВСписке(аргрез лит список, арг цел индекс, арг лит значение)
дано являетсяСписком(список) и длинаКоллекции(список) >= индекс
нач
удалитьИзСписка(список, индекс)
добавитьКСписку(список, значение, индекс)
кон



| Object implementation

алг лит новыйОбъект нач 
знач := __кк__объект_разделитель + новыйСписок + __кк__объект_разделитель + новыйСписок
кон


алг лит собратьОбъект(арг лит ключи, арг лит значения) нач 
знач := __кк__объект_разделитель + ключи + __кк__объект_разделитель + значения
кон


алг разобратьОбъект(арг лит объект, рез лит ключи, рез лит значения) 
дано являетсяОбъектом(объект)
нач 
цел р1 = 1, р2
р2 := __индексПовторенияНомер(объект, __кк__объект_разделитель, 2)
ключи := объект[р1+1:р2-1]
значения := объект[р2+1:длин(объект)]
кон


алг лог являетсяОбъектом(арг лит объект) нач
знач := длин(объект) > 1 и объект[1] = __кк__объект_разделитель
кон


алг задатьПоКлючу(аргрез лит объект, арг лит ключ, арг лит значение) 
дано являетсяОбъектом(объект)
нач
лит ключи, значения
разобратьОбъект(объект, ключи, значения)
цел индексКлюча
индексКлюча := найтиВСписке(ключи, ключ)
если индексКлюча = -1 то
добавитьККонцуСписка(ключи, ключ)
добавитьККонцуСписка(значения, значение)
иначе
заменитьВСписке(значения, индексКлюча, значение)
все
объект := собратьОбъект(ключи, значения)
кон


алг цел длинаОбъекта(арг лит объект) 
дано являетсяОбъектом(объект)
нач
лит ключи, значения
разобратьОбъект(объект, ключи, значения)
знач := длинаКоллекции(ключи)
кон


алг лог имеетКлюч(арг лит объект, арг лит ключ)
дано являетсяОбъектом(объект)
нач
лит ключи, значения
разобратьОбъект(объект, ключи, значения)
знач := найтиВСписке(ключи, ключ) <> -1
кон


алг лит получитьПоКлючу(арг лит объект, арг лит ключ)
дано имеетКлюч(объект, ключ)
нач
лит ключи, значения
разобратьОбъект(объект, ключи, значения)
знач := получитьИзСписка(значения, найтиВСписке(ключи, ключ))
кон




|
| Kumir Serialization API
| @author Tapeline
| @version 1
| 

алг сим __hexd(арг цел н) 
дано 0 <= н <= 15
нач 
если 0 <= н <= 9 то
знач := юнисимвол(юникод('0') + н)
иначе
знач := юнисимвол(юникод('a') + н - 10)
все
кон

алг цел __dfromhex(арг сим с) нач 
если юникод('0') <= юникод(с) <= юникод('9') то
знач := юникод(с) - юникод('0')
иначе
знач := юникод(с) - юникод('a') + 10
все
кон

алг лит hex(арг цел н, арг цел размер) нач
лит результат = ""
цел число 
число := н
нц пока число > 0
результат := __hexd(mod(число, 16)) + результат
число := div(число, 16)
кц
если размер > 0 то
нц пока длин(результат) < размер
результат := "0" + результат
кц
все
знач := результат
кон

алг цел hexToDec(арг лит h) нач
цел степ = 1
цел н = 0
цел индекс
индекс := длин(h)
нц пока индекс >= 1
н := н + __dfromhex(h[индекс]) * степ
степ := степ * 16
индекс := индекс - 1
кц
знач := н
кон

алг лит сериализовать(арг лит данные) нач
лит результат = ""
цел индекс = 1
нц для индекс от 1 до длин(данные)
результат := результат + hex(юникод(данные[индекс]), 4)
кц
знач := результат
кон

алг лит десериализовать(арг лит данные) нач
лит результат = ""
цел индекс = 1
нц пока индекс <= длин(данные)
результат := результат + юнисимвол(hexToDec(данные[индекс:индекс+3]))
индекс := индекс + 4
кц
знач := результат
кон










